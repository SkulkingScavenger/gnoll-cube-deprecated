<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with obj_abstract_chamber{
    instance_destroy();
}
with obj_abstract_door{
    instance_destroy();
}
with obj_cell_parent{
    instance_destroy();
}
with tileset{
    instance_destroy();
}
tile_layer_delete(2);

ds_list_destroy(chamber_list);
ds_list_destroy(door_list);

ds_list_destroy(npc_type_list_ground_small);
ds_list_destroy(npc_type_list_ground_medium);
ds_list_destroy(npc_type_list_ground_large);
ds_list_destroy(npc_type_list_air_small);
ds_list_destroy(npc_type_list_air_medium);
ds_list_destroy(npc_type_list_air_large);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Transition (Enter)
if(entering){
  var l,cell, xpos, ypos;
  
  switch(load_phase){
  case 0: //if !defined, create abstract objects from scripts
    if(lc &lt; destined_chamber.chunk_count || destined_chamber.is_defined){
      with (destined_chamber){
        script_execute(chunk[crnt_dungeon.lc],0,0);
      }
      lc += 1;
    }else{
      is_defined = true;
      load_phase += 1;
      lc = 0;
    }
    break;
  case 1: //create cell manifestations from abstract objects
    //create the chamber cells
    l = ds_list_size(destined_chamber.cell_list);
    if(lc &lt; l){
      for(i=0;i&lt;group_size &amp;&amp; lc&lt;l;i+=1){
        cell = ds_list_find_value(destined_chamber.cell_list,lc);
        lastcreated = instance_create(cell.cell_x,cell.cell_y,cell.cell_type);
        lastcreated.z = cell.cell_z;
        lastcreated.tileset = tileset;
        //lastcreated.cell_index = cell.cell_index;
        lastcreated.abstract = cell;
        cell.manifestation = lastcreated;
        lc += 1;
      }
    }else{
      load_phase += 1;
      lc = 0;
    }
    break;
  case 2:
    //after all cells have been created, call constructors
    l = ds_list_size(destined_chamber.cell_list);
    if(lc &lt; l){
      for(i=0;i&lt;group_size &amp;&amp; lc&lt;l ;i+=1){
        cell = ds_list_find_value(destined_chamber.cell_list,lc);
        lastcreated = cell.manifestation;
        with (lastcreated){event_user(0);}
        lc += 1;
      }
    }else{
      load_phase += 1;
      lc = 0;
    }
    break;
  case 3: //create npcs
    if (global.master){
      //create npcs
      l = ds_list_size(destined_chamber.npc_list);
      if(lc&lt;l){
        for(i=0;i&lt;group_size &amp;&amp; lc&lt;l;i+=1){
          npc = ds_list_find_value(destined_chamber.npc_list,lc);
          lastcreated = instance_create(npc.npc_x,npc.npc_y,npc.npc_type);
          if(npc.npc_hp &gt; 0){
            lastcreated.hitpoints = npc.npc_hp;
          }
          lastcreated.abstract = npc;
          npc.manifestation = lastcreated;
          with (lastcreated){event_user(0);}
          lc += 1;
        }
      }else{
        lc = 0
        load_phase += 1;
      }
    }else{
      load_phase += 1;
    }
    break;
  case 4: //create tiles
    if(lc &lt; destined_chamber.tile_chunk_count){
      with (destined_chamber){
        script_execute(tile_chunk[crnt_dungeon.lc],0,0);
      }
      lc += 1;
    }else{
      //conclude load process
      with (destined_chamber){
        event_user(2);//dungeon_specific effects
      }
      if(transition_type = "chamber_to_chamber"){
        xpos = destined_chamber.startlocation[destination_coordinates].cell_x;
        ypos = destined_chamber.startlocation[destination_coordinates].cell_y;
      }else if(transition_type = "room_to_chamber"){
        xpos = destined_chamber.startlocation_main.cell_x;
        ypos = destined_chamber.startlocation_main.cell_y;
      }
      crnt_chamber = destined_chamber;
      character_spawn(xpos,ypos);
      //end load
      entering = false;
      lc = 0;
    }
    break;
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Transition (Exit)
if(exiting){
  var l,crnt_npc;
  switch(load_phase){
  case 0: //delete existing room objects
    if(lc &gt;= 0){
      //lc = ds_list_size(npc_list);//put this in the external call bit
      for(i=0;i&lt;group_size &amp;&amp; lc &gt;= 0;i+=1){
        crnt_npc = crnt_chamber.npc_list[|lc];
        if (!crnt_npc.dead){
          crnt_npc.npc_x = crnt_npc.manifestation.x;
          crnt_npc.npc_y = crnt_npc.manifestation.y;
          crnt_npc.npc_hp = crnt_npc.manifestation.hitpoints;
          with (crnt_npc.manifestation){instance_destroy();}
        }else{
          ds_list_delete(crnt_chamber.npc_list,lc);
        }
        lc -= group_size
      }
    }else{
        //clear the spot
      with obj_cell_parent{
        instance_destroy();
      }
      with obj_npc_parent{
        instance_destroy();
      }
      lc = 0;
      load_phase += 1;
    }
    break;
  case 1: //delete existing room tiles
    if(lc &lt; room_height + 256){
      l = group_size;
      for(i=0;i&lt;l;i+=1){
        tile_layer_delete(room_height-lc*16);
        lc += 1;
      }
    }else{
      exiting = false;
      if(transition_type == "chamber_to_chamber"){
        event_user(0);//enter next room
      }
    }
    break;
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Exit Room
exiting = true;
lc = ds_list_size(crnt_chamber.npc_list)-1;
load_phase = 0;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Enter Room

background_color = tileset.color;
destined_chamber.npcid_index = 0; //start a new array of npcs
//if the chamber hasn't been generated already, generate it.
if (!destined_chamber.is_defined){
    with(destined_chamber){generate_chamber();}
}
entering = true;
lc = 0;
load_phase = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
